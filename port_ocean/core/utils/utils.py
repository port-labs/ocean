import asyncio
import json
from typing import Iterable, Any, TypeVar, Callable, Awaitable, AsyncGenerator, cast

from loguru import logger
from pydantic import BaseModel


from port_ocean.clients.port.client import PortClient
from port_ocean.core.models import Entity, Runtime
from port_ocean.core.models import EntityPortDiff
from port_ocean.core.ocean_types import RAW_RESULT
from port_ocean.exceptions.core import (
    RawObjectValidationException,
    IntegrationRuntimeException,
)

T = TypeVar("T", bound=tuple[list[Any], ...])


def zip_and_sum(collection: Iterable[T]) -> T:
    return tuple(sum(items, []) for items in zip(*collection))  # type: ignore


def validate_result(result: Any) -> RAW_RESULT:
    if not isinstance(result, list):
        raise RawObjectValidationException(
            "Expected list[dict[str, Any]], Error: Result is not a list"
        )
    for index, item in enumerate(result):
        if not isinstance(item, dict):
            raise RawObjectValidationException(
                f"Expected list[dict[str, Any]], Error: Item {index} is not a dict"
            )
        for key in item.keys():
            if not isinstance(key, str):
                raise RawObjectValidationException(
                    f"Expected list[dict[str, Any]], Error: Key {key} is not a string"
                )

    return result


def is_same_entity(first_entity: Entity, second_entity: Entity) -> bool:
    return (
        first_entity.identifier == second_entity.identifier
        and first_entity.blueprint == second_entity.blueprint
    )


async def validate_integration_runtime(
    port_client: PortClient,
    requested_runtime: Runtime,
) -> None:
    logger.debug("Validating integration runtime")
    current_integration = await port_client.get_current_integration(
        should_raise=False, should_log=False
    )
    current_installation_type = current_integration.get("installationType", "OnPrem")
    if current_integration and not requested_runtime.is_installation_type_compatible(
        current_installation_type
    ):
        raise IntegrationRuntimeException(
            f"Invalid Runtime! Requested to run existing {current_installation_type} integration in {requested_runtime} runtime."
        )


Q = TypeVar("Q")


async def gather_and_split_errors_from_results(
    task: Iterable[Awaitable[Q]],
    result_threshold_validation: Callable[[Q | Exception], bool] | None = None,
) -> tuple[list[Q], list[Exception]]:
    valid_items: list[Q] = []
    errors: list[Exception] = []
    results = await asyncio.gather(*task, return_exceptions=True)
    for item in results:
        # return_exceptions will also catch Python BaseException which also includes KeyboardInterrupt, SystemExit, GeneratorExit
        # https://docs.python.org/3/library/asyncio-task.html#asyncio.gather
        # These exceptions should be raised and not caught for the application to exit properly.
        # https://stackoverflow.com/a/17802352
        if isinstance(item, BaseException) and not isinstance(item, Exception):
            raise item
        elif isinstance(item, Exception):
            errors.append(item)
        elif not result_threshold_validation or result_threshold_validation(item):
            valid_items.append(item)

    return valid_items, errors


def _get_entity_key(entity: Entity) -> tuple[str, str]:
    identifier = entity.identifier
    if isinstance(identifier, BaseModel):
        identifier = identifier.dict()

    key_part = (
        json.dumps(identifier, sort_keys=True)
        if isinstance(identifier, dict)
        else str(identifier)
    )
    return key_part, entity.blueprint


def get_port_diff(before: Iterable[Entity], after: Iterable[Entity]) -> EntityPortDiff:
    entities_at_port: dict[tuple[str, str], Entity] = {}
    entities_generated_by_integration: dict[tuple[str, str], Entity] = {}
    created = []
    modified: dict[tuple[str, str], Entity] = {}

    # Create dictionaries for before and after lists
    for entity in before:
        entities_at_port[_get_entity_key(entity)] = entity

    for entity in after:
        entities_generated_by_integration[_get_entity_key(entity)] = entity

    # Find created, modified, and deleted objects
    for key, obj in entities_generated_by_integration.items():
        if key not in entities_at_port:
            created.append(obj)
        else:
            # if the entity is already in the port, it is modified
            modified[key] = obj

    # Remove the entities that were not generated by the integration but which exist in port
    # We do this by subtracting the keys of the entities that were generated by the integration from the keys of the entities that are in port
    for key in modified.keys():
        entities_at_port.pop(key)

    return EntityPortDiff(
        created=created,
        modified=list(modified.values()),
        deleted=list(entities_at_port.values()),
    )


def are_teams_different(
    first_team: str | None | list[Any] | dict[str, Any],
    second_team: str | None | list[Any] | dict[str, Any],
) -> bool:
    if isinstance(first_team, list) and isinstance(second_team, list):
        return sorted(first_team) != sorted(second_team)
    return first_team != second_team


def are_entities_fields_equal(
    first_entity_field: dict[str, Any], second_entity_field: dict[str, Any]
) -> bool:
    """
    Compare two entity fields by serializing them to JSON and comparing their SHA-256 hashes.
    Removes keys with None values before comparison if the corresponding key doesn't exist in the other dict.

    Args:
        first_entity_field: First entity field dictionary to compare
        second_entity_field: Second entity field dictionary to compare

    Returns:
        bool: True if the entity fields have identical content
    """
    first_entity_field_copy = first_entity_field.copy()

    for key in list(first_entity_field.keys()):
        if first_entity_field[key] is None and key not in second_entity_field:
            del first_entity_field_copy[key]

    first_props = json.dumps(first_entity_field_copy, sort_keys=True)
    second_props = json.dumps(second_entity_field, sort_keys=True)
    return first_props == second_props


def are_entities_different(first_entity: Entity, second_entity: Entity) -> bool:
    if first_entity.title != second_entity.title:
        return True
    if are_teams_different(first_entity.team, second_entity.team):
        return True
    if not are_entities_fields_equal(first_entity.properties, second_entity.properties):
        return True
    if not are_entities_fields_equal(first_entity.relations, second_entity.relations):
        return True

    return False


async def resolve_entities_diff(
    source_entities: list[Entity],
    target_entities_generator: AsyncGenerator[list[Entity], None],
) -> list[Entity]:
    """
    Maps the entities into filtered list of source entities, excluding matches found in target that needs to be upserted
    Args:
        source_entities: List of entities from third party source
        target_entities: List of existing Port entities

    Returns:
        list[Entity]: Filtered list of source entities, excluding matches found in target
    """
    source_entities_dict = {}

    if (
        len(
            [
                entity
                for entity in source_entities
                if entity.is_using_search_identifier or entity.is_using_search_relation
            ]
        )
        > 0
    ):
        return source_entities

    for entity in source_entities:
        key = _get_entity_key(entity)
        source_entities_dict[key] = entity

    async for batch_target_entities in target_entities_generator:
        if not batch_target_entities:
            continue

        for entity in batch_target_entities:
            key = _get_entity_key(entity)

            if key in source_entities_dict and not are_entities_different(
                entity, cast(Entity, source_entities_dict.get(key))
            ):
                source_entities_dict.pop(key, None)

    return list(source_entities_dict.values())
